syntax = "proto3";
package tokenstate;

import "libp2p-provider.proto";

message QueryStateTsidRequest {}
message QueryStateTsidResponse { bytes stateTsid = 1; }
message QueryTeaBalanceRequest { bytes acct = 1; }
message QueryTeaBalanceResponse {
  bytes balance_bytes = 1;
  bytes stateTsid = 2;
}
message QueryTokenBalanceRequest { bytes acct = 1;
  uint64 tokenId = 2;
}
message QueryTokenBalanceResponse {
  bytes balance_bytes = 1;
  bytes stateTsid = 2;
}
message QueryAppAesRequest {
  uint64 tokenId = 1;
}
message GenAppAesRequest {
  uint64 tokenId = 1;
  bytes tsidBytes = 2;
}
message GenAppConsumeAcctRequest {
  uint64 tokenId = 1;
  bytes tsidBytes = 2;
}

message QueryAppAesResponse {
  bytes key = 1;
}
message QueryAuthOpsRequest{
  bytes authKey = 1;
}

message DepositRequest{
  bytes ctx = 1;
  bytes acct = 2;
  bytes amt = 3;
}
message RefundRequest{
  bytes ctx = 1;
  bytes acct = 2;
  bytes amt = 3;
}
message ConsumeFromDepositRequest{
  bytes ctx = 1;
  bytes acct = 2;
  bytes amt = 3;
}
message ConsumeFromAccountRequest{
  bytes ctx = 1;
  bytes acct =  2;
  bytes amt = 3;
}
message PaymentFromDepositRequest{
  bytes ctx = 1;
  bytes acct = 2;
  bytes to = 3;
  bytes amt = 4;
}
message CommitRequest { bytes ctx = 1; }
message TopupRequest {
  bytes ctx = 1;
  bytes to = 2;
  bytes amt = 3;
}
message WithdrawRequest {
  bytes ctx = 1;
  bytes from = 2;
  bytes amt = 3;
}

message MoveRequest {
  bytes ctx = 1;
  bytes from = 2;
  bytes to = 3;
  bytes amt = 4;
}

/// To simplify the coding and process, we did not use One_of the
/// protobuf syntax. We just check if ctx bytes is empty, then check
/// the error. The protocol here is that if there is error, set the ctx
/// to empty bytes
message StateOperateResponse {
  bytes ctx = 1;
  bytes operateError = 2;
}

message ExportStateRequest {
}

message ExportStateResponse {
  bytes data = 1;
}

message ImportStateRequest {
  bytes data = 1;
}

message SyncStateRequest {
}

message SyncStateResponse {
  bytes data = 1;
}

message GetConsumeAccountRequest{
  uint64 tokenId = 1; 
}

message StateReceiverMessage {
  string uuid = 1;
  oneof msg {
    StateCommand StateCommand = 2;
    StateFollowup StateFollowup = 3;
    StateQuery StateQuery = 4;
  }
}

message StateReceiverRelayRequest {
  string uuid = 1;
  string targetConnId = 2;
  string targetKey = 3;
  libp2p.TargetType targetType = 4;
  oneof msg {
    SignAndSendExtrinsicRequest SignAndSendExtrinsicRequest = 5;
  }
}

message StateReceiverResponse {
  string uuid = 1;
  oneof msg {
    DirectResponse DirectResponse = 2;
    CommandFollowupResponse CommandFollowupResponse = 3;
    TeaBalanceResponse TeaBalanceResponse = 4;
  }
}

message StateCommand {
  bytes data = 1;
}

message StateFollowup {
  bytes data = 1;
}

message StateQuery {
  oneof msg {
    TeaBalanceRequest TeaBalanceRequest = 1;
    SignAndSendExtrinsicRequest SignAndSendExtrinsicRequest = 2;
  }
}

message TeaBalanceRequest {
  string account = 1;
  bytes auth = 2;
}

message SignAndSendExtrinsicRequest {
  bytes extrinsicCall = 1;
  uint64 tokenId = 2;
}

// Direct response do not return something meaningful, it just indicates that
//  the request has been relayed successfully, and may return real result in
//  another response
message DirectResponse {}

message TeaBalanceResponse {
  bytes balance = 1;
  bytes ts = 2;
}

message CommandFollowupResponse {
  bytes ts = 1;
  bytes hash = 2;
  bytes sender = 3;
}