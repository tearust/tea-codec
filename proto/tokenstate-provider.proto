syntax = "proto3";
package tokenstate;

message QueryStateTsidRequest {}
message QueryStateTsidResponse { bytes stateTsid = 1; }
message QueryTeaBalanceRequest { bytes acct = 1; }
message QueryTeaBalanceResponse {
  bytes balance_bytes = 1;
  bytes stateTsid = 2;
}
message QueryTokenBalanceRequest {
  bytes acct = 1;
  uint64 tokenId = 2;
}
message QueryTokenBalanceResponse {
  bytes balance_bytes = 1;
  bytes stateTsid = 2;
}
message QueryAppAesRequest {
  uint64 tokenId = 1;
}
message GenAppAesRequest {
  uint64 tokenId = 1;
  bytes tsidBytes = 2;
}
message QueryAppAesResponse {
  bytes key = 1;
}
message CommitRequest { bytes ctx = 1; }
message TopupRequest {
  bytes ctx = 1;
  bytes to = 2;
  bytes amt = 3;
}
message WithdrawRequest {
  bytes ctx = 1;
  bytes from = 2;
  bytes amt = 3;
}

message MoveRequest {
  bytes ctx = 1;
  bytes from = 2;
  bytes to = 3;
  bytes amt = 4;
}

/// To simplify the coding and process, we did not use One_of the
/// protobuf syntax. We just check if ctx bytes is empty, then check
/// the error. The protocol here is that if there is error, set the ctx
/// to empty bytes
message StateOperateResponse {
  bytes ctx = 1;
  bytes operateError = 2;
}