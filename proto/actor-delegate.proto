syntax = "proto2";

package actor_delegate;

message CidHash{
  required string cid = 1;
  required bytes hash = 2;
}

message TaskRegisterRequest{
  repeated CidHash cidHash = 1;
  //required bytes ekey1 = 2;
  required bytes blockChainAccount = 3;
  required CidHash wasm = 4;   // wasm 
  required CidHash wasmManifest = 5;  // wasm manifest
  required CidHash wasmChecker = 6;  // wasm checker
  required uint32 payment = 7;  // gas
}

message TaskRegisterResponse{
  optional string RefNum = 1;
  optional string RsaPubKey = 3;
  optional string Error = 2;
}

message DataRegisterRequest{
  required bytes depositTxId = 1;
  required bytes blockChainAccount = 3;
}

message DataRegisterResponse{
  oneof res{
    string Error = 1;
    string RsaPubKey = 2;
  }
}

message ServiceRegisterRequest{
  required bytes depositTxId = 1;
  required bytes blockChainAccount = 3;
}

message ServiceRegisterResponse{
  oneof res{
    string Error = 1;
    string RsaPubKey = 2;
  }
}

message DataUploadCompletedNotify{
  oneof Cid {//user need to specity to Adapter what type of data he uploads to IPFS. We can use query string type=Data or type=Description in URL
            //Adapter use this query string to set this value
    string CidData = 1;
    string CidDescription = 2;
  }
  required string RsaPubKey = 3;//RsaPubKey = somekey in query string. Adapter need to parse this query param and send the RsaPubKey to Delegator to verify
  optional string KeyUrlEncoded = 4; //If the uploaded data is encrypted. this key_url_encoded must be in the query params. Otherwise no one can decrypt this data.
                                      // if the data is not encrypted, such as description is not encrypted. The key_url_encoded is None.
                                      // In order to be used in url, this key is Url_encoded. Please url_decode before use.

  repeated KeyValuePair kvp = 5;//This can be empty [] if user did not specify in the upload URL query string except RsaPubKey is a must.
                                //Adapter do not parse (except for RsaPubKey), just pass through to this Vec<KeyValuePair> to Delegator. 
                                //Delegator handles the logic

}

message ServiceUploadCompletedNotify{
  oneof Cid{
    string CidCode = 1;//Cid of uploaded wasm file
    string CidDescription = 2;//This is any format of description. Most likely a toml file. We do not parse or process.
    string CidCapCheckerWasm = 3;// Developer can choose one of two CapCheck format: Wasm or Json
                                // Only one of the two needs to be exist. We do not allow both of them exist. If it happens, use wasm and ignore json
                                // 
    string CidCapCheckerJson = 4;//Either json or wasm
  }
  required string RsaPubKey = 5; //Note: a full upload workflow contains only one rsa_pub_key but may have multiple http post requests. All of these http post request
                                //will share the same rsa_pub_key. 
                                //Among these http post requests, only one of them can contain kvp
  optional string KeyUrlEncoded = 6; //If the uploaded data is encrypted. this key_url_encoded must be in the query params. Otherwise no one can decrypt this data.
                                      // if the data is not encrypted, such as description is not encrypted. The key_url_encoded is None.
                                      // In order to be used in url, this key is Url_encoded. Please url_decode before use.
}

message KeyValuePair{
  required string key = 1;
  required string value = 2;
}

message AddNewTask{
  required bytes teaId = 1;
  required bytes refNum = 2;
  required bytes rsaPub = 3;
  required string capCid = 4;
  required string modelCid = 5;
  required string dataCid = 6;
  required uint32 payment = 7;
}

message TaskBody {
  required string manifestCid = 4;
  // the wasm/yaml file that used to check capabilities. Executor needs to run this
  // wasm/yaml against its own runtime to know if itself is capable to run this task
  required string capCid = 3;
  required string wasmCid = 5;
  //Use IPFS block_get(dataCid) to download the data. This data is the parameter of the task wasm
  //By default, this data (after downloaded from IPFS) is encrypted. The decrypt key is ekey1 (after decrypted by rsa_pub though)
  required string dataCid = 6;
  //This eKey1 can be decrypted by delegate (who issue the rsa key pair). After decrypted, it can be
  //used to decrypt data so that the task wasm can run against
  required bytes ekey1 = 7;//this is base64 encoded bytes.
}

message Task {
  required bytes refNum = 1;//this is [u8] not base64 nor hex
  required bytes delegateId = 2;
  required string modelCid = 3;
  required string bodyCid = 4;
  required uint32 payment = 5;
}

message Data {
  required bytes delegateTeaId = 2;//This is TeaId not Ephemeral Id because this is long term ID. Others can lookup layer1 to find what is the current peer_id of this delegator
  required string modelCid = 3;
  required string bodyCid = 4;
  required uint32 payment = 5;
}

message Service {
  required bytes delegateId = 2;
  required string modelCid = 3;
  required string bodyCid = 4;
  required uint32 payment = 5;
}

message Node {
  required bytes teaId = 1;
  repeated bytes peers = 2;
}

message AddNewTaskRequest {
  required Task task = 1;
}

message AddNewTaskResponse {
  required bytes accountId = 1;
  required Task task = 2;
}

message AddNewDataResponse {
  required bytes delegatorEphemeralId = 1;
  required string deploymentId = 2;
  required string DataCid = 3;//The cid of encrypted data or code. We consider code is also data in this case
  required string DescriptionCid = 4;//the cid of description object(or DAG). This description can be any format. We can define the format somewhere else.
  optional string CapCid = 5;//When this is a data or a service without any requirment to check capability, we can set this property to None.
                              //The wannabepinner will not check capability if this is none
                              //It make sense for most data type pinner because we only check if it is a valid Tea Node.
                              //For service pinner, in most case we may need to run a capchecker to make sure the service pinner has the 
                              //capabilities required.
}

message CompleteTaskRequest {
  required bytes refNum = 1;
  required bytes teaId = 2;
  required bytes delegateSig = 3;
  required bytes result = 4;
  required bytes resultSig = 5;
}

message NotifyDelegateTaskComplete{
  required bytes refNum = 1;

}
