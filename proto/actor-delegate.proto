syntax = "proto2";

package actor_delegate;

message CidHash{
  required string cid = 1;
  required bytes hash = 2;
}

message TaskRegisterRequest{
  repeated CidHash cidHash = 1;
  //required bytes ekey1 = 2;
  required bytes blockChainAccount = 3;
  required CidHash wasm = 4;   // wasm 
  required CidHash wasmManifest = 5;  // wasm manifest
  required CidHash wasmChecker = 6;  // wasm checker
  required uint32 payment = 7;  // gas
}

message TaskRegisterResponse{
  optional string RefNum = 1;
  optional string RsaPubKey = 3;
  optional string Error = 2;
}

message DataRegisterRequest{
  required bytes depositTxId = 1;
  required bytes blockChainAccount = 3;
}

message DataRegisterResponse{
  oneof res{
    string Error = 1;
    string RsaPubKey = 2;
  }
}

message DataUploadCompletedNotify{
  oneof Cid{
    string CidData = 1;
    string CidDescription = 2;
  }
  required string RsaPubKey = 3;
}

message AddNewTask{
  required bytes teaId = 1;
  required bytes refNum = 2;
  required bytes rsaPub = 3;
  required string capCid = 4;
  required string modelCid = 5;
  required string dataCid = 6;
  required uint32 payment = 7;
}



/////////  Communication between delegate and executor
message GeneralTaskMessage{
  enum MessageType{
    ApplyToExecuteTaskRequest = 0;//body is bytes of ApplyToExecuteTaskRequest
    WinnerExecutorCert = 1;//body is bytes of WinnerExecutorCert
    ExecutorCompleteTask = 3;
  };
  required MessageType messageType = 1;
  required bytes payload = 2;
}

message WinnerExecutorCertPayload{
  required bytes refNum = 1;
  required bytes winnerTeaId = 2;//the winner who send the application and lucky get approved by delegator
  required bytes signature = 3;//signer is delegate, msg is tea_id(32bytes) + ref_num(32bytes)
  optional bytes secKeysRsaBytes = 4;//Delegate decrypt eKey1, then encrypt using Executor's rsa pub key
}


message ApplyToExecuteTaskRequest{
  required bytes refNum = 1;//[u8] NOT a base 64 string slices. but if encoded using base64, it will become the pubsub topic. 
  required bytes ekey1 = 2;//Send to delegate, asking him to decrypt and send back
  required bytes rsaPubKey = 3;//Delegate will use this RSA Pub Key to encrypt the key1 when sending to Executor. Format is tpm_protp::RsaKeyPairPemPcsk1.publicKey string.as_bytes()
  required bytes executorTeaId = 6;//The Tea Id of the executor who apply for this task
  required bytes signature = 7;//The Ed25519 sig for concat bytes: executorTeaId + capcheckers[0] + ..+ capcheckers[n]
}

message TaskBody {
  required string manifestCid = 4;
 // the wasm/yaml file that used to check capabilities. Executor needs to run this
 // wasm/yaml against its own runtime to know if itself is capable to run this task
  required string capCid = 3;
  required string wasmCid = 5;
  //Use IPFS block_get(dataCid) to download the data. This data is the parameter of the task wasm
  //By default, this data (after downloaded from IPFS) is encrypted. The decrypt key is ekey1 (after decrypted by rsa_pub though)
  required string dataCid =6;
  //This eKey1 can be decrypted by delegate (who issue the rsa key pair). After decrypted, it can be
  //used to decrypt data so that the task wasm can run against
  required bytes ekey1 = 7;//this is base64 encoded bytes.
}


/////////  Communication between delegate and facade.
message Task {
  required bytes refNum = 1;//this is [u8] not base64 nor hex
  required bytes delegateId = 2;
  required string modelCid = 3;
  required string bodyCid = 4;
  required uint32 payment = 5;
}

message Node {
  required bytes teaId = 1;
  repeated bytes peers = 2;
}

message AddNewTaskRequest {
  required Task task = 1;
}

message AddNewTaskResponse {
  required bytes accountId = 1;
  required Task task = 2;
}

message CompleteTaskRequest {
  required bytes refNum = 1;
  required bytes teaId = 2;
  required bytes delegateSig = 3;
  required bytes result = 4;
  required bytes resultSig = 5;
}

message CompleteTaskResponse {
  required bytes refNum = 1;
  required bytes accountId = 2;
  required bytes result = 3;
}


message NotifyDelegateTaskComplete{
  required bytes refNum = 1;

}

message P2P{
  oneof m{
    string Error = 1;
    P2pPingMessage ping = 2;
  }
}

message P2pPingMessage{
  required string hi = 1;
}

message ApplyToBePinnerRequest{
  required string deploymentId = 1;//this is cid of pinner_key's pub key
  required bytes rsaPubKey = 2;//Delegate will use this RSA Pub Key to encrypt the key1 when sending to Executor. Format is tpm_protp::RsaKeyPairPemPcsk1.publicKey string.as_bytes()
  required bytes wannabePinnerId = 3;//The ephemeral Id of the wannabe pinner
  required bytes signature = 4;//The Ed25519 sig for concat bytes: wannabe_ephemeral_id + rsa_key_pub
}

message ApplyToBePinnerResponse{
  required bytes pinnerKeyEncrypted =1; //The full pinner key encoded by rsa_pubkey from wannabe pinner.
  required bytes signature = 4;//The Ed25519 sig for concat bytes: pinner's ephemeral key + pinner_key_enc
}

message PeerApprovePinnerMessage {
  oneof Message {
      PeerApprovePinnerRequest Request = 1;
      PeerApprovePinnerResponse Response = 2;
  }
}

message PeerApprovePinnerRequest {
  required string deploymentId = 1;//this is cid of pinner_key's pub key
  required uint32 nonce = 2; // this is an random number for verify
}

message PeerApprovePinnerResponse {
  required string deploymentId = 1;//this is cid of pinner_key's pub key
  required bytes signature = 2;//The Ed25519 sig for nonce
}