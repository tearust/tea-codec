syntax = "proto2";

package actor_delegate;

message CidHash{
  required string cid = 1;
  required bytes hash = 2;
}

message TaskRegisterRequest{
  repeated CidHash cidHash = 1;
  //required bytes ekey1 = 2;
  required bytes blockChainAccount = 3;
  required CidHash wasm = 4;   // wasm 
  required CidHash wasmManifest = 5;  // wasm manifest
  required CidHash wasmChecker = 6;  // wasm checker
  required uint32 payment = 7;  // gas
}

message TaskRegisterResponse{
  optional string RefNum = 1;
  optional string RsaPubKey = 3;
  optional string Error = 2;
}

message DataRegisterRequest{
  required bytes depositTxId = 1;
  required bytes blockChainAccount = 3;
}

message DataRegisterResponse{
  oneof res{
    string Error = 1;
    string RsaPubKey = 2;
  }
}

message ServiceRegisterRequest{
  required bytes depositTxId = 1;
  required bytes blockChainAccount = 3;
}

message ServiceRegisterResponse{
  oneof res{
    string Error = 1;
    string RsaPubKey = 2;
  }
}

message DataUploadCompletedNotify{
  oneof Cid {//user need to specity to Adapter what type of data he uploads to IPFS. We can use query string type=Data or type=Description in URL
            //Adapter use this query string to set this value
    string CidData = 1;//this could be data or wasm code's cid
    string CidDescription = 2;
    string CidCapchecker = 3; //If uploaded is code, CidCapchecker is valid capchecker cid. If uploaded is data, this is empty string ""
  }
  required string RsaPubKey = 10;//RsaPubKey = somekey in query string. Adapter need to parse this query param and send the RsaPubKey to Delegator to verify
  optional string KeyUrlEncoded = 11; //If the uploaded data is encrypted. this key_url_encoded must be in the query params. Otherwise no one can decrypt this data.
                                      // if the data is not encrypted, such as description is not encrypted. The key_url_encoded is None.
                                      // In order to be used in url, this key is Url_encoded. Please url_decode before use.
}

message AddNewTask{
  required bytes teaId = 1;
  required bytes refNum = 2;
  required bytes rsaPub = 3;
  required string capCid = 4;
  required string modelCid = 5;
  required string dataCid = 6;
  required uint32 payment = 7;
}

message TaskBody {
  required string manifestCid = 4;
  // the wasm/yaml file that used to check capabilities. Executor needs to run this
  // wasm/yaml against its own runtime to know if itself is capable to run this task
  required string capCid = 3;
  required string wasmCid = 5;
  //Use IPFS block_get(dataCid) to download the data. This data is the parameter of the task wasm
  //By default, this data (after downloaded from IPFS) is encrypted. The decrypt key is ekey1 (after decrypted by rsa_pub though)
  required string dataCid = 6;
  //This eKey1 can be decrypted by delegate (who issue the rsa key pair). After decrypted, it can be
  //used to decrypt data so that the task wasm can run against
  required bytes ekey1 = 7;//this is base64 encoded bytes.
}

message Task {
  required bytes refNum = 1;//this is [u8] not base64 nor hex
  required bytes delegateId = 2;
  required string modelCid = 3;
  required string bodyCid = 4;
  required uint32 payment = 5;
}

message Data {
  required bytes delegatorEphemeralId = 1;
  required string deploymentId = 2;
  required string dataCid = 3;//The cid of encrypted data or code. We consider code is also data in this case
  required string descriptionCid = 4;//the cid of description object(or DAG). This description can be any format. We can define the format somewhere else.
  optional string capCid = 5;//When this is a data or a service without any requirment to check capability, we can set this property to None.
                              //The wannabepinner will not check capability if this is none
                              //It make sense for most data type pinner because we only check if it is a valid Tea Node.
                              //For service pinner, in most case we may need to run a capchecker to make sure the service pinner has the 
                              //capabilities required.
}

message Service {
  required bytes delegateId = 2;
  required string modelCid = 3;
  required string bodyCid = 4;
  required uint32 payment = 5;
}

message Node {
  required bytes teaId = 1;
  repeated bytes peers = 2;
}

message AddNewTaskRequest {
  required Task task = 1;
}

message AddNewTaskResponse {
  required bytes accountId = 1;
  required Task task = 2;
}

message AddNewDataRequest {
  required Data data = 1;
}

message AddNewDataResponse {
  required bytes accountId = 1;
  required Data data = 2;
}

message CompleteTaskRequest {
  required bytes refNum = 1;
  required bytes teaId = 2;
  required bytes delegateSig = 3;
  required bytes result = 4;
  required bytes resultSig = 5;
}

message CompleteTaskResponse {	
  required bytes refNum = 1;	
  required bytes accountId = 2;	
  required bytes result = 3;	
}

message NotifyDelegateTaskComplete{
  required bytes refNum = 1;

}
