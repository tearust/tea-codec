syntax = "proto3";
package p2p;

message ResponseError{
  string error = 1;
}

message PeerApprovePinnerRequest {
  string deploymentId = 1;//this is cid of pinner_key's pub key
  uint32 nonce = 2; // this is an random number for verify
  string uuid = 3; // this is the uuid of pinner store item
}

message PeerApprovePinnerResponse {
  string deploymentId = 1;//this is cid of pinner_key's pub key
  bytes signature = 2;//The Ed25519 sig for nonce
  string uuid = 3; // this is the uuid of pinner store item
}

message ApplyToBePinnerRequest{
  string deploymentId = 1;//this is cid of pinner_key's pub key
  bytes rsaPubKey = 2;//Delegate will use this RSA Pub Key to encrypt the key1 when sending to Executor. Format is tpm_protp::RsaKeyPairPemPcsk1.publicKey string.as_bytes()
  bytes wannabePinnerId = 3;//The ephemeral Id of the wannabe pinner
  bytes signature = 4;//The Ed25519 sig for concat bytes: wannabe_ephemeral_id + rsa_key_pub
}

message ApplyToBePinnerResponse{
  string deploymentId = 1;//this is cid of pinner_key's pub key
  bytes pinnerKeyEncrypted = 2; //The full pinner key encoded by rsa_pubkey from wannabe pinner.
  bytes key1Encrypted = 3; //The key1 encoded by rsa_pubkey from upstream pinner.
  bytes upstreamPinnerTeaId = 4;//use the upstream tea_id to make a broacasting chain so that we can trace back when make payment or verify
  //we use tea_id instead of ephemeral_id because this chain would be a long life time use. ephemeral key changes
  // every time the tea node reboot.
  // Base on today's idea, the first revenue comes from hosting as pinner will 100% go to upstream pinner. after that
  // the revenue doens't need to share to upstream
  // problem: what if the data is only for one time use?
  bytes signature = 5;//The Ed25519 sig for concat bytes: pinner's ephemeral key + pinner_key_enc
}

message WinnerExecutorCert{
  bytes refNum = 1;
  bytes winnerTeaId = 2;//the winner who send the application and lucky get approved by delegator
  bytes signature = 3;//signer is delegate, msg is tea_id(32bytes) + ref_num(32bytes)
  bytes secKeysRsaBytes = 4;//Delegate decrypt eKey1, then encrypt using Executor's rsa pub key
}


message ApplyToExecuteTaskRequest{
  bytes refNum = 1;//[u8] NOT a base 64 string slices. but if encoded using base64, it will become the pubsub topic. 
  bytes ekey1 = 2;//Send to delegate, asking him to decrypt and send back
  bytes rsaPubKey = 3;//Delegate will use this RSA Pub Key to encrypt the key1 when sending to Executor. Format is tpm_protp::RsaKeyPairPemPcsk1.publicKey string.as_bytes()
  bytes executorTeaId = 6;//The Tea Id of the executor who apply for this task
  bytes signature = 7;//The Ed25519 sig for concat bytes: executorTeaId + capcheckers[0] + ..+ capcheckers[n]
}

message ErrandExecutionRequest{
  bytes delegatorTeaId = 1;//The Tea Id of the delegator about the errand
  string hash = 2; // this is hash of the errand
  oneof code {
    ErrandDeploymentCode DeploymentCode = 3; // this is deployment code for the errand
    ErrandAdhocCode AdhocCode = 4; // this is adhoc code for the errand
  }
  oneof data {
    ErrandDeploymentData DeploymentData = 5; // this is deployment data for the errand
    string AdhocData = 6; // this is adhoc data for the errand
  }
  oneof signature {
    bytes Code = 7; // this is signature about adhoc code
    bytes Data = 8; // this is signature about adhoc data
    bool None = 9; // fill this item if there is no signature
  }
}

message ErrandDeploymentData{
  string deploymentId = 1; //this is deployment is of deployed data
  string cid = 2; //this is cid of deployed data
}

message ErrandDeploymentCode{
  string deploymentId = 1; //this is deployment is of deployed code
  string cid = 2; //this is cid of deployed code
}

message ErrandAdhocCode{
  string code = 1; // this is base64 encoded wasm bin without encryption
  string capChecker = 2; // this is base64 encoded capabilities checker wasm with encryption
}

message GeneralMsg{
  oneof msg {
    ResponseError error = 1;
    PeerApprovePinnerRequest PeerApproveRequest = 2;
    PeerApprovePinnerResponse PeerApproveResponse = 3;
    ApplyToBePinnerRequest ApplyPinnerRequest = 4;
    ApplyToBePinnerResponse ApplyPinnerResponse = 5;
    ApplyToExecuteTaskRequest ApplyToExecuteTaskRequest = 6;
    WinnerExecutorCert WinnerExecutorCert = 7;
    ErrandExecutionRequest ErrandExecutionRequest = 8;
  }
}